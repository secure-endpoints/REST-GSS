<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc tocindent="no" ?>
<?rfc autobreaks="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc2119 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
  <!ENTITY rfc2616 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml'>
  <!ENTITY rfc2743 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2743.xml'>
  <!ENTITY rfc4401 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4401.xml'>
  <!ENTITY rfc4422 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4422.xml'>
  <!ENTITY rfc5056 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5056.xml'>
  <!ENTITY rfc5246 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml'>
  <!ENTITY rfc5587 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5587.xml'>
  <!ENTITY rfc5801 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5801.xml'>
  <!ENTITY rfc5929 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5929.xml'>
  <!ENTITY rfc4121 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4121.xml'>
  <!ENTITY rfc5280 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml'>
]>


<rfc category="std" docName="draft-williams-rest-gss-00" ipr="pre5378Trust200902">
  <front>
    <title abbrev="REST-GSS">RESTful Hypertext Transfer Protocol Application-Layer Authentication Using Generic Security Services</title>

    <author fullname="Nicolas Williams" initials="N." surname="Williams">
      <organization abbrev="Cryptonector">Cryptonector LLC</organization>

      <address>
        <email>nico@cryptonector.com</email>
      </address>
    </author>

    <date day="27" month="May" year="2011" />

    <area>Security</area>

    <workgroup>NETWORK WORKING GROUP</workgroup>

    <keyword>Internet-Draft</keyword>

    <abstract>

      <t>This document describes a method for application-layer
        authentication in Hypertext Transfer Protocol (HTTP)
        applications using Generic Security Services Application
        Programming Interface (GSS-API) mechanisms via, for simplicity,
        the Simple Authentication and Security Layers (SASL) mechanism
        bridge known as "GS2".  This approach to authentication allows
        for pluggability, mutual authentication, and channel binding,
        all with no changes to HTTP nor the Transport Layer
        Security.</t>

    </abstract>

  </front>

  <middle>

    <section title="Introduction">

      <t>Hypertext transfer Protocol (HTTP) <xref target='RFC2616'/>
        applications often require authentication and related security
        services.  These applications have a plethora of odd choices for
        authentication, such as: Transport Layer Security (TLS) <xref
          target='RFC5246'/> with pre-shared secret keys (PSK), TLS with
        user certificates <xref target='RFC5280'/>, HTTP Basic, HTTP
        Digest, and HTTP/Negotiate authentication, posting of HTML forms
        with usernames and passwords filled in, and various methods
        based on passing tokens via HTTP URIs, such as OAuth and OpenID
        [add references].  All these methods of authentication leave
        something to be desired.  Worse, these methods of authentication
        operate at various different network layers, making abstraction
        particularly difficult, if not impossible.  Among the many
        downsides these methods have is the lack of a secure method of
        tying all of a logged-in session's HTTP requests and responses
        to the session, with most browser-based applications using
        "cookies".</t>

      <t>We propose an alternative method of authentication that
        operates at the application layer, and which provides
        applications with access to a large number of actual security
        mechanisms.  This method is based on an exchange of
        authentication messages via HTTP POST to either a well-known URI
        or to a URI indicated by the server or agreed a priori.  These
        authentication messages are mostly those of mechanisms defined
        for the GSS-API <xref target='RFC2743'/>.  Channel binding <xref
          target='RFC5056'/> is used to bind authentication to TLS
        channels.  Sessions are referenced via a session URI that is
        indicated and authenticated in all requests for a session.</t>
      
      <t>This method is simple, yet powerful because it is a framework
        for application-layer authentication that is a) built on
        off-the-shelf technologies, b) requiring no modifications to
        either HTTP nor TLS, c) that puts the application in control of
        authentication, and d) is pluggable, all the while improving
        security for HTTP applications whenever GSS mechanisms are used
        that provide mutual authentication.</t>

      <section title="Conventions used in this document">

        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
          document are to be interpreted as described in <xref
            target="RFC2119"></xref> .</t>

      </section>

    </section>

    <section title="The Protocol">

      <t>At some point the client application determines that REST-GSS
        authentication is required.  How the client does this is
        discussed in a sub-section below, but for the purposes of this
        discussion, the client MUST learn or know a URI that will be
        used to initiate REST-GSS authentication.  Once the client knows
        that REST-GSS authentication is required the client begins by
        constructing an initial message as described below, then it
        POSTs it to the agreed-upon URI.</t>
      
      <t>The server SHOULD respond to initial authentication messages
        with either an error or a 201 response.  If there is no error
        and there is a response authentication message, it will be
        returned to the client as the representation of the resource
        created and named in the 201 response, otherwise, if there is no
        error then the new resource will have an empty representation.
        The new resource name shall be the name of the REST-GSS session,
        known as the 'session URI'.</t>

      <t>For security mechanisms that require multiple round-trips then
        additional messages from the client SHALL be POSTed to the
        session URI, and any response messages from the server will be
        returned in 200 results as the new representation of the session
        resource.</t>

      <t>The server generally responds to all POSTs to the REST-GSS
        login and session URIs with a 201 or a 200 status, respectively.
        Failure is signalled by the authentication messages described
        below.</t>
      
      <t>Any GETs of a valid session URI SHALL return a representation of
        the status of that session, else the response to the GET SHALL
        be an error.</t>

      <t>A DELETE of the session URI logs the session out.</t>

      <t>The requests and responses that make up a session are tied to the
        session via the session URI, which is sent in a header.  The
        requests and responses that make up a session SHOULD be
        authenticated by an HMAC taken over the concatenation of: the
        session URI, the channel bindings of the channel protecting the
        request (or response), and a timestamp.</t>

      <section title="Authentication Message Format">

        <t>The authentication messages from clients to servers SHALL be
          formed as per the Simple Authentication and Security Layer's
          <xref target='RFC4422'/> GSS-API bridge (known as 'GS2') <xref
            target='RFC5801'/>.  The reason for this is simple:
          implementors who lack a GSS-API implementation will find it
          simpler to implement certain mechanisms if the GS2 framework
          is used.</t>

        <t>The authentication messages from servers to clients SHALL be
          formed SASL GS2 authentication messages pre-fixed with a
          header indicating authentication status.  The header consists
          of a single byte, an ASCII character 'S' (success), 'F'
          (failure), or 'C' (continue needed).</t>

        <t>Channel binding SHOULD be used whenever a) there is a secure
          channel (namely, TLS), and b) the selected GSS-API mechanism
          supports mutual authentication and channel binding.</t>

        <t>[Must specify authorization ID preparation...]</t>

      </section>

      <section title="Authorization ID Form">

        <t>The form of the authorization ID, if any is supported, SHALL
          be specified by the application.  Most applications are
          expected to use empty authorization IDs.</t>

      </section>

      <section title="Mechanism and Channel Binding Type Negotiation">

        <t>The representation of the resource to which initial
          authentication messages are POSTed MUST be a list of SASL/GS2
          mechanism names separated by an ASCII comma (','), optionally
          followed by an ASCII newline and a comma-separated list of
          channel binding types supported by the server.  Clients MAY
          GET this resource in order to select a suitable mechanism.</t>

        <t>If a channel binding type list is not advertised by the
          server then the client SHOULD pick a channel binding type as
          agreed a priori.  Applications must specify any pre-agreed
          channel binding type selection criteria.</t>

        <t>In any case of ambiguity or failure to specify, the client
          SHOULD pick the tls-server-end-point channel binding type if
          a server certificate was used to authenticate the server
          end-point of the TLS channel, else the client SHOULD pick
          tls-unique.</t>

      </section>

      <section title="Session Status Representation">

        <t>The status of a session SHALL be obtained by GETting the
          session resource.  The status of a session SHALL consist of:
          &lt;TBD&gt; (in particular we should have a boolean to
          indicate whether the session is fully established, a timestamp
          indicating hard expiration, a relative time specification
          indicating what the idle timer, if any, is, and, possibly, some
          items indicating authorization attributes of the client user
          such as the SASL authorization ID).</t>

      </section>

      <section title="Session Binding via HMAC">

        <t>[NOTE: Originally I meant to use GSS-API "MIC" tokens
          instead of HMACs.  I switched to HMAC on the theory that this
          will make it easier for some implementors.  However, using an
          HMAC does mean doing something about hash agility -- an
          inconvenient complication.  I'm leaving this as using an HMAC
          for now, and we'll figure out what's the best way forward
          later. -Nico]</t>

        <t>An HMAC is used to bind HTTP requests and responses to
          containing sessions.  A request can be bound to more than one
          session for session combination purposes.</t>

        <t>The HMAC is keyed using GSS_Pseudo_random() <xref
            target='RFC4401'/>, which is called with the following
          inputs to generate two HMAC keys (one for requests, one for
          responses):

          <list style='symbols'>

            <t>the established security context as the 'context' input
              argument;</t>

            <t>GSS_C_PRF_KEY_FULL as the 'prf_key' input argument;</t>

            <t>the string "request" or "response" as the 'prf_in' input
              argument (not including any trailing zero bytes), for the
              request and response keys, respectively;</t>

            <t>16 as the 'desired_output_len' input argument.</t>

          </list>

        </t>

        <t>Requests bear an HMAC, keyed with the request key, taken over
          a minimized form of the request containing only the following
          items:

          <list style='symbols'>

            <t>the request start line;</t>

            <t>the Host header field, if any;</t>

            <t>a Request-Date field with the same value form as the
              'Date' field (this field MUST be sent in the request as
              well);</t>

            <t>a Request-Nanoseconds field bearing a nanoseconds
              component of the time at which the request was made, as an
              unsigned integer in decimal, ASCII respresentation (e.g.,
              1234567) (this field MUST be sent in the request as well);</t>

            <t>a Channel-Binding field bearing the channel bindings data
              (base64-encoded) of the channel over which the message is
              being sent (note: the channel bindings should be prefixed
              with the channel binding type as described in RFC5056, and
              prior to base64 encoding)), if there is a channel (this
              field MUST NOT be included in the request);</t>

            <t>the request body if and only if there is no channel to
              bind to, else an empty request.</t>

          </list>

        </t>

        <t>The request HMAC is base64-encoded, prefixed with the session
          URI (separated by an ASCII semi-colon) and placed in a header
          field named REST-GSS-Request-MAC.  Multiple MACs may be placed
          in this field.</t>

        <t>The HMAC hash function used SHOULD be SHA-256.</t>

        <t>[Describe the same for responses.]</t>

      </section>

      <section title="Server Indication of Authentication Requirement">

        <t>When the server wishes to indicate that the client must
          authenticate in order to access a given resource, then the
          server MUST respond to the client's HTTP request with either a
          redirection to a web page with a 303 redirect to a login page
          (this in the case of browser applications) or a
          to-be-determined 4xx error indicating that access requires
          REST-GSS login and, optionally directing the client to the REST-GSS login
          URI by listing that URI in a field named 'REST-GSS-Authenticate'.</t>

      </section>

    </section>

    <section title="IANA Considerations">

      <t>This document has IANA considerations: new HTTP fields,
        and, possibly, new HTTP status codes.  These need to be
        registered.  Registration information to-be-added.</t>

    </section>

    <section title="Security Considerations">

      <t>[Add text...]</t>

      <section title="User Interface and JavaScript Interface Recommendations">

        <t>[Add informative description of desired HTML DOM and
          XMLHttpRequest elements. -Nico]</t>

      </section>

    </section>

  </middle>

  <back>
    <references title="Normative References">
      &rfc2119;
      &rfc2616;
      &rfc2743;
      &rfc4401;
      &rfc4422;
      &rfc5056;
      &rfc5246;
      &rfc5587;
      &rfc5801;
      &rfc5929;
    </references>

    <references title="Informative References">
      &rfc4121;
      &rfc5280;
    </references>
  </back>
</rfc>
